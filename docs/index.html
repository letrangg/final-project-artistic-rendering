<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta property="og:image" content="https://i.ibb.co/GWg1TTh/web-banner-2.png" />
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

<div class="container">
  <nav class="navbar navbar-expand-lg navbar-light bg-light" style="background-color: #e6b3cc;">
  <a class="navbar-brand" href="index.html">About</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
    <div class="navbar-nav">
      <a class="nav-item nav-link active" href="proposal.html">Proposal<span class="sr-only">(current)</span></a>
      <a class="nav-item nav-link" href="Milestone.html">Milestone<span class="active"></span></a>
      <a class="nav-item nav-link" href="final.html">Final Report<span class="active"></span></a>
      <a class="nav-item nav-link" href="#">Reference<span class="sr-only">(current)</span></a>
    </div>
  </div>
  Richard Chen, Dahyun Kim and Trang Le
</div>
<head>
<link href="https://fonts.googleapis.com/css?family=Heebo:300|Noto+Sans+JP:100" rel="stylesheet">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  .container {
    align-self: center;
    align-items: center;
    justify-content: center;
    display: flex;
  }

  div.padded {
     padding-top: 0px;  
     padding-right: 310px;  
     padding-bottom: 0.25in;  
     padding-left: 310px; 
     line-height: 3; 
  }
body, html {
  height: 100%;
  margin: 0;
}

.hero-image {
  background-image: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url("https://i.ibb.co/GWg1TTh/web-banner-2.png");
  height: 50%;
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
  position: relative;
}

h1.font1 {
  font-weight: 300;
  font-size-adjust: 900%;
  font-family: Lora;
  opacity: 0.8;
}


h1.title {
  font-weight: 100;
  font-family: 'Noto Sans JP', sans-serif;
  opacity: 1.0;
  color: #efb8e4;
}

p.font_title {
  font-weight: 100;
  font-family: Lora;
  opacity: 0.5;
}

p.body {
  font-weight: 100;
  font-family: 'Noto Sans JP', sans-serif;
  opacity: 1.0;

}


.hero-text {
  text-align: center;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-weight: 400;
}

.hero-text button {
  border: none;
  outline: 0;
  display: inline-block;
  padding: 10px 25px;
  color: black;
  background-color: #ddd;
  text-align: center;
  cursor: pointer;
}

.hero-text button:hover {
  background-color: #555;
  color: white;
}
</style>
</head>
<body>

<div class="hero-image">
  <div class="hero-text">
    <h1 style="font-size:80px" class="font1">CS 184 project</h1>
    <p class="font_title"><font size="+40">Artistic rendering</font></p>
  </div>
</div>

<p>
<h1 align="middle" class="title" style="color: #8c7877;">Abstract</h1>>

<div class="padded" style="font-family: 'Times'; color: #111111;">
<p class="body">

We built a Java-based application to simulate watercolor in real-time, using a GUI to offer a relatively good drawing experience with our app. We structured our project into two parts: the main program & GUI generator, and the per-GPU computation. The main program & GUI generator was written using Processing[3], a Java-based tool that lets you write high-level functions in the graphics pipeline such as the initialization part and the draw loop, and it generates a GUI for us. This saved us from having to implement our own GUI from scratch, which was not the main intent of this project. The per-GPU computation was written using GLSL to build OpenGL[4] shaders to perform heavy computations in the GPU. This coincided well with our actual algorithms because the method we based our computation on, the Lattice Boltzman Method (LBM),  was a cell-by-cell method by nature. This allowed us to easily implement our algorithm inside the OpenGL shaders as well as allow us to make modifications to the necessary parts of the algorithm when needed. In our latest version of the app, we ended up modifying many of our original shaders built for the LBM for increased stability as well as better visuals. 

